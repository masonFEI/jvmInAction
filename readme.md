
> 栈管运行，堆管存储


## java代码执行流程
1. 编译（前端编译，与执行引擎中的编译成热点代码（后端编译）形成区分），形成字节码文件
2. 字节码文件运行在jvm之上

![Java代码执行流程图](assets/image/java代码执行流程.png)

## jvm的架构模型
> 一种是基于栈的指令集架构（Hotspot），另一种是基于寄存器的指令集架构。
> 基于栈的指令集架构以零地址为主，基于寄存器的指令集架构都以一地址指令，二地址指令，三地址指令为主
>
> .class文件反编译的命令为 javap -v xxx.class
> 
>  jps 查看执行中的进程

## 内存结构
### 概述
> 如果自己手写一个java虚拟机的话，主要考虑哪些结构呢？类加载器和执行引擎
>

![内存结构概述](assets/image/内存结构概述.jpg)

### 类加载器子系统
> 负责从文件系统或者网络中加载Class文件。
> 加载的类信息放在一块称为方法区的内存空间。
> 除了类的信息外，方法区还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）

### 类的加载过程(loading)
1. 通过一个类的全限定名获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

### 类的加载过程(Linking)
> 验证，准备，解析
> final修饰的static,在编译的时候就会分配
> 解析：将常量池的符号引用转换为直接引用的过程
> jclasslib bytecode viewer, 打开字节码文件，可以安装idea插件，打开字节码文件
> binary Viewer, 查看字节码文件，HxD 也可以查看字节码文件

### 类的加载过程(Initialization)
- 初始化阶段就是执行类构造器方法&lt;clinit>()的过程
-  &lt;clinit>()不同于类的构造器（关联：构造器是虚拟机视角下的&lt;init>()）
- 此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来
- 构造器方法中指令按语句在源文件中出现的顺序执行
- 若该类具有父类，jvm会保证子类的&lt;clinit>()执行前，父类的&lt;clinit>()已经执行完毕
- 虚拟机必须保证一个类的&lt;clinit>()方法在多线程下被同步加锁

### 类加载器的分类
![类加载器的分类](assets/image/类加载器的分类.jpg)
> 上图四者之间的关系是包含关系。不是上层下层，也不是子父类的继承关系。
> jvm支持两种类型的类加载器，分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）
> 将所有派生于抽象类ClassLoader 的类加载器都划分为自定义类加载器
> ctrl+H 查看类的继承关系

#### 启动类加载器（引导类加载器，Bootstrap ClassLoader）
  - 这个类加载使用c/c++语言实现的，嵌套在JVM内部
  - 并不继承自java.lang,ClassLoader,没有父加载器
  - 加载扩展类和应用程序类加载器，并指定为他们的父类加载器
  - 出于安全考虑，Bootstrap启动类加载器只加载包名为java,javax,sun等开头的类
#### 扩展类加载器（Extension ClassLoader）
  - 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext 子目录下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。
#### 应用程序类加载器（系统类加载器，AppClassLoader）
  - 负责加载环境变量classpath或系统属性 java.class.path 指定路径下的类库
  - 该类加载器是程序中默认的类加载器，一般来说，java应用的类都是由它来完成加载
  - 通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器
#### 用户自定义类加载器
  - 为什么要自定义类加载器？
    - 隔离加载类（类冲突，做类的仲裁）
    - 修改类加载的方式
    - 扩展加载源
    - 防止源码泄露（对字节码文件加解密）
  - 开发人员可以通过继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求
  - 如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁
#### 关于ClassLoader
> ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）
> sun.misc.Launcher 它是java虚拟机的入口应用
##### 获取ClassLoader的途径
1. 获取当前类的ClassLoader: clazz.getClassLoader()
2. 获取当前线程上下文的ClassLoader：Thread.currentThread().getContextClassLoader()
3. 获取系统的ClassLoader: ClassLoader.getSystemClassLoader()
4. 获取调用者的ClassLoader:DriverManager.getCallerClassLoader()

### 双亲委派机制
> java 虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时，才会将它的class文件加载到内存生成class对象。
> 而且加载某个类的class文件时，java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式，
#### 工作原理
1. 如果一个类加载器收到了类加载请求，它并不会自己去加载，而是把这个请求委托给父类的加载器去执行;
2. 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器
3. 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。
#### 优势
> 避免类的重复加载
> 保护程序安全，防止核心API被随意篡改，自定义类：java.lang.String  java.lang.FxyStart

#### 沙箱安全机制
> 自定义String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java/lang/String.class）,
> 报错信息说没有main方法就是因为加载的是rt.jar包中的String类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。

#### 其他
> 在jvm中表示两个class对象是否为同一个类存在两个必要条件：
> 1. 类的完整类名必须一致，包括包名；
> 2. 加载这个类的ClassLoader(指ClassLoader实例对象)必须相同。
>
> JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。
> 当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。

### 运行时数据区
![运行时数据区](assets/image/运行时数据区.jpg)
>jvm虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。
> 另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁
> 1. 每个线程：独立包括程序计数器，栈，本地栈。
> 2. 线程间共享：堆，堆外内存（永久代或元空间，代码缓存）
#### class Runtime
> 一个jvm实例对应一个runtime的实例

#### JVM中的线程说明
> 在Hotspot jvm 每个线程都与操作系统的本地线程直接映射；
> 当一个java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。java线程执行终止后，本地线程也会回收。
> 
> Hotspot jvm里包括以下线程：虚拟机线程，周期任务线程，GC线程，编译线程（将字节码编译成本地代码），信号调度线程

#### PC寄存器
##### 概述
![PC寄存器的概述](assets/image/PC寄存器的概述.jpg)
> JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。PC寄存器也称为程序钩子。
> 
> 作用：PC寄存器用来存储指向下一条指令的地址，也是即将要执行的指令代码，由执行引擎读取下一条指令。
##### 使用举例
![PC寄存器的使用举例](assets/image/PC寄存器的使用举例.jpg)

##### 问题
> 1. 使用PC寄存器存储字节码指令地址有什么用呢？
> 
>   因为CPU需要不停地切换各个线程，切换回来以后，就得知道接着从哪开始继续执行。
>   jVM字节码解释器需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。
> 2. PC寄存器为什么会被设定为线程私有？
>
>   为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器。

#### 虚拟机栈
##### 概述
> java指令都是根据栈来设计的。每个线程都会创建一个虚拟机栈，其内部保存一个个的栈帧，对应这一次次的java方法调用。
> 生命周期和线程一致。访问速度仅次于程序计数器。对于栈来说不存在垃圾回收问题，可能存在内存溢出的问题
> 
> 作用：主管java程序的运行，它保存方法的局部变量（8种基本数据类型、对象的引用地址 ）、部分结果，并参与方法的调用和返回。
> 局部变量vs成员变量（或属性）
> 基本数据类型 vs 引用数据类型（类，数组，接口）

##### 虚拟机栈的异常
> java栈的大小是动态的或者是固定不变的
> 
> 固定大小的java虚拟机栈(Hotspot中默认是固定大小的)，可能会抛出StackOverflowError
> 
> 如果java虚拟机栈可以动态扩展，可能会抛出一个OutOfMemoryError；使用 -Xss 选项设置虚拟机栈的大小

##### 栈的存储结构和运行原理
> 栈中的数据都是以栈帧为单位存在的，每个方法都各自对应一个栈帧。栈帧是一个内存块区，是一个数据集，维系着方法执行过程中的各种数据信息
> 
> OOP的基本概念：类，对象;
> 类中基本结构：field(属性，字段，域)、method


> 1. 不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧
> 2. 如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。
> 3. java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。

##### 栈帧的内部结构
![栈帧的内部结构](assets/image/栈帧的内部结构.jpg)
> <span style='color:red'>局部变量表(Local Variables)</span><br>
> <span style='color:red'>操作数栈(Operand Stack)(或表达式栈)</span><br>
> 动态连接(Dynamic Linking)(或指向运行时常量池的方法引用)<br>
> 方法返回地址（Return Address）(或方法正常退出或者异常退出的定义)<br>
> 一些附加信息

